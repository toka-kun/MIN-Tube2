<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clipboard Visualizer â€” ã‚ã‚‰ã‚†ã‚‹å½¢å¼ã‚’å®‰å…¨ã«å¯è¦–åŒ–</title>
  <style>
    :root {
      --bg: #0f1320;
      --panel: #161b2e;
      --soft: #212946;
      --accent: #6ea8fe;
      --accent-2: #9ad0ff;
      --text: #e6ebff;
      --muted: #a7b1d1;
      --ok: #3bd671;
      --warn: #ffb86b;
      --danger: #ff6b6b;
      --code-bg: #0a0d17;
      --border: #2b335c;
      --shadow: 0 8px 28px rgba(0,0,0,0.35);
      --radius: 14px;
    }
    * { box-sizing: border-box }
    html, body {
      margin: 0;
      height: 100%;
      background: linear-gradient(120deg, #0f1320 0%, #0f1320 40%, #111634 100%);
      color: var(--text);
      font: 16px/1.65 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Hiragino Sans", "Yu Gothic", Meiryo, sans-serif;
    }
    a { color: var(--accent) }
    header {
      position: sticky; top: 0; z-index: 5;
      backdrop-filter: saturate(160%) blur(10px);
      background: rgba(15,19,32,0.55);
      border-bottom: 1px solid var(--border);
    }
    .bar {
      max-width: 1100px; margin: 0 auto; padding: 14px 20px;
      display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center;
    }
    .title {
      font-weight: 700; letter-spacing: 0.3px; display: flex; gap: 10px; align-items: center;
    }
    .badge {
      font-size: 12px; color: var(--muted); border: 1px solid var(--border);
      padding: 2px 8px; border-radius: 999px; background: rgba(33,41,70,0.4);
    }
    .actions { display: flex; gap: 10px; flex-wrap: wrap }
    button, .btn {
      all: unset; display: inline-flex; align-items: center; gap: 8px;
      background: linear-gradient(180deg, #1c2444 0%, #18203b 100%);
      color: var(--text); border: 1px solid var(--border); padding: 10px 14px;
      border-radius: 12px; cursor: pointer; box-shadow: var(--shadow); transition: transform .05s ease;
    }
    button:hover { transform: translateY(-1px) }
    button:active { transform: translateY(0) scale(0.98) }
    .btn-ghost {
      background: rgba(22,27,46,0.6);
    }
    .btn-ok { border-color: #2f9a55; }
    main { max-width: 1100px; margin: 24px auto; padding: 0 20px 60px }
    .hero {
      background: radial-gradient(1200px 400px at 20% 0%, rgba(110,168,254,0.15) 0%, transparent 60%),
                  radial-gradient(1000px 400px at 80% 0%, rgba(154,208,255,0.12) 0%, transparent 60%),
                  var(--panel);
      border: 1px solid var(--border); border-radius: var(--radius);
      padding: 18px; display: grid; grid-template-columns: 1.2fr 1fr; gap: 16px;
    }
    .dropzone {
      border: 2px dashed #3c4b85; border-radius: 12px;
      padding: 18px; background: rgba(23,29,50,0.7);
      min-height: 150px; display: grid; place-items: center; text-align: center;
      transition: border-color .2s ease, background .2s ease;
    }
    .dropzone.highlight { border-color: var(--accent); background: rgba(23,29,50,0.9) }
    .hint { color: var(--muted); font-size: 14px }
    .stat {
      display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
    }
    .card {
      background: var(--soft); border: 1px solid var(--border); border-radius: 12px;
      padding: 12px; box-shadow: var(--shadow);
    }
    .grid {
      margin-top: 24px; display: grid; gap: 14px;
    }
    .item {
      background: var(--panel); border: 1px solid var(--border); border-radius: 14px;
      overflow: hidden; box-shadow: var(--shadow);
    }
    .item-head {
      display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center;
      padding: 12px 14px; background: linear-gradient(180deg,#1a2040,#171c36);
      border-bottom: 1px solid var(--border);
    }
    .type-pill {
      display: inline-flex; align-items: center; gap: 8px;
      background: rgba(110,168,254,0.14); border: 1px solid #3c5aa8; color: #cfe3ff;
      padding: 6px 10px; border-radius: 999px; font-size: 13px;
    }
    .meta { color: var(--muted); font-size: 13px; display: flex; gap: 12px; flex-wrap: wrap }
    .item-actions { display: flex; gap: 10px; flex-wrap: wrap }
    .item-body { padding: 12px 14px; display: grid; gap: 12px }
    .section-title { font-weight: 700; color: #cfe3ff; font-size: 14px }
    pre, code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: var(--code-bg); color: #d7e0ff; border: 1px solid #222843;
      border-radius: 10px; padding: 10px; overflow: auto;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace }
    .kv { display: grid; grid-template-columns: max-content 1fr; gap: 6px 12px; }
    .kv b { color: #cfe3ff }
    .preview-frame {
      width: 100%; min-height: 160px; border: 1px solid var(--border); border-radius: 8px; background: #0b1024;
    }
    .media { max-width: 100%; border-radius: 10px; border: 1px solid var(--border); background: #0b1024 }
    .pill { display:inline-block; font-size:12px; color:#cfe3ff; background:#26325f; padding:3px 8px; border:1px solid #3a4a84; border-radius:999px; }
    .footer-note { color: var(--muted); font-size: 13px; margin-top: 10px }
    .empty {
      text-align: center; color: var(--muted); border: 1px dashed var(--border);
      border-radius: 12px; padding: 18px; background: rgba(22,27,46,0.5);
    }
    .wrap { word-break: break-word; white-space: pre-wrap }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .spacer { height: 10px }
    @media (max-width: 900px) {
      .hero { grid-template-columns: 1fr; }
      .stat { grid-template-columns: 1fr; }
      .bar { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <div class="title">
        <span>ğŸ“‹ Clipboard Visualizer</span>
        <span class="badge">Paste/Read any MIME safely</span>
      </div>
      <div class="actions">
        <button id="readClipboardBtn" class="btn btn-ok" title="ãƒ–ãƒ©ã‚¦ã‚¶è¨±å¯ãŒå¿…è¦ã§ã™">ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰èª­ã¿å–ã‚‹</button>
        <button id="clearBtn" class="btn btn-ghost">ã‚¯ãƒªã‚¢</button>
      </div>
    </div>
  </header>

  <main>
    <section class="hero">
      <div id="dropzone" class="dropzone" contenteditable="true">
        <div>
          <div style="font-weight:700;font-size:18px">ã“ã“ã«ãƒšãƒ¼ã‚¹ãƒˆï¼ˆCmd/Ctrl+Vï¼‰</div>
          <div class="hint">ãƒ†ã‚­ã‚¹ãƒˆãƒ»HTMLãƒ»ç”»åƒãƒ»å‹•ç”»ãƒ»CSVãƒ»JSONãƒ»RTFãƒ»XMLãƒ»ä»»æ„ã®MIMEã«å¯¾å¿œã€‚ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚„å³ã‚¯ãƒªãƒƒã‚¯è²¼ã‚Šä»˜ã‘ã‚‚OKã€‚</div>
          <div class="spacer"></div>
          <div class="row">
            <span class="pill">è²¼ã‚Šä»˜ã‘ã‚¤ãƒ™ãƒ³ãƒˆã§æ•æ‰</span>
            <span class="pill">Clipboard APIã§ç›´æ¥èª­ã¿å–ã‚Š</span>
            <span class="pill">ã‚ªãƒªã‚¸ãƒŠãƒ«Blobã‚’ä¿æŒãƒ»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</span>
            <span class="pill">HTMLã¯iframeã§å®‰å…¨ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</span>
          </div>
        </div>
      </div>
      <div class="stat">
        <div class="card">
          <div class="section-title">ä½¿ã„æ–¹</div>
          <ul style="margin:8px 0 0 18px">
            <li><b>ãƒšãƒ¼ã‚¹ãƒˆ:</b> ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’å½“ã¦ã¦ Cmd/Ctrl+V</li>
            <li><b>ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—:</b> ç”»åƒã‚„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã“ã“ã«</li>
            <li><b>ç›´æ¥èª­ã¿å–ã‚Š:</b> ä¸Šéƒ¨ãƒœã‚¿ãƒ³ã§è¨±å¯å¾Œã«å–å¾—</li>
            <li><b>ä¿å­˜:</b> å„ã‚¢ã‚¤ãƒ†ãƒ ã®ã€Œãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã€ã§å…ƒãƒ‡ãƒ¼ã‚¿</li>
          </ul>
          <div class="footer-note">æ³¨: ä¸€éƒ¨ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ç‰¹æ®Šãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ãƒ†ã‚­ã‚¹ãƒˆåŒ–ãŒåˆ¶é™ã•ã‚Œã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿æŒãƒ»ä¿å­˜ã¯å¯èƒ½ã§ã™ã€‚</div>
        </div>
        <div class="card">
          <div class="section-title">æ¤œå‡ºãƒ»ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</div>
          <ul style="margin:8px 0 0 18px">
            <li><b>ãƒ†ã‚­ã‚¹ãƒˆ:</b> ãƒ—ãƒ¬ãƒ¼ãƒ³/RTF/CSV/JSON/XMLã‚’æ•´å½¢</li>
            <li><b>HTML:</b> ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹iframeã§å®‰å…¨ãƒ¬ãƒ³ãƒ€</li>
            <li><b>ç”»åƒ/å‹•ç”»/éŸ³å£°:</b> ãã®ã¾ã¾ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</li>
            <li><b>ãƒã‚¤ãƒŠãƒª:</b> ã‚µã‚¤ã‚ºã€Hex/Base64ã€ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="grid" id="items">
      <div class="empty">ã¾ã ä½•ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ä½•ã‹ã‚’ãƒšãƒ¼ã‚¹ãƒˆã™ã‚‹ã¨ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
    </section>
  </main>

  <script>
    // Utility: create element
    const el = (tag, props = {}, children = []) => {
      const node = document.createElement(tag);
      Object.entries(props).forEach(([k,v]) => {
        if (k === 'class') node.className = v;
        else if (k === 'style') Object.assign(node.style, v);
        else if (k.startsWith('on') && typeof v === 'function') node.addEventListener(k.slice(2), v);
        else if (k === 'dataset') Object.assign(node.dataset, v);
        else node.setAttribute(k, v);
      });
      [].concat(children).filter(Boolean).forEach(c => {
        if (typeof c === 'string') node.appendChild(document.createTextNode(c));
        else node.appendChild(c);
      });
      return node;
    };

    // State
    const itemsContainer = document.getElementById('items');
    const dropzone = document.getElementById('dropzone');
    const readClipboardBtn = document.getElementById('readClipboardBtn');
    const clearBtn = document.getElementById('clearBtn');

    let itemCount = 0;

    // Helpers
    const prettyBytes = (n) => {
      if (n < 1024) return n + ' B';
      const units = ['KB','MB','GB','TB'];
      let i = -1; do { n /= 1024; i++; } while (n >= 1024 && i < units.length - 1);
      return n.toFixed(n >= 100 ? 0 : n >= 10 ? 1 : 2) + ' ' + units[i];
    };

    const detectKind = (type, name = '') => {
      const t = (type || '').toLowerCase();
      if (t.startsWith('text/')) return 'text';
      if (t === 'text/html') return 'html';
      if (t === 'text/rtf' || name.toLowerCase().endsWith('.rtf')) return 'rtf';
      if (t === 'application/json' || /\.json$/i.test(name)) return 'json';
      if (t === 'text/csv' || /\.csv$/i.test(name)) return 'csv';
      if (/xml/.test(t) || /\.xml$/i.test(name)) return 'xml';
      if (/^image\//.test(t)) return 'image';
      if (/^video\//.test(t)) return 'video';
      if (/^audio\//.test(t)) return 'audio';
      if (/pdf$/.test(t) || /\.pdf$/i.test(name)) return 'pdf';
      if (!t && name) {
        if (/\.(png|jpg|jpeg|gif|webp|bmp|svg)$/i.test(name)) return 'image';
        if (/\.(mp4|webm|mov|mkv)$/i.test(name)) return 'video';
        if (/\.(mp3|wav|ogg|m4a)$/i.test(name)) return 'audio';
      }
      return 'binary';
    };

    const sanitizeSrcDoc = (html) => {
      // Minimal neutralization: remove scripts and event handlers
      const doc = new DOMParser().parseFromString(html, 'text/html');
      doc.querySelectorAll('script, iframe, object, embed').forEach(n => n.remove());
      // Remove inline event handlers
      doc.querySelectorAll('*').forEach(n => {
        [...n.attributes].forEach(a => {
          if (/^on/i.test(a.name)) n.removeAttribute(a.name);
        });
      });
      // Return cleaned HTML string
      return '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;
    };

    const blobFromString = (str, type='text/plain') => new Blob([str], { type });

    const toHexDump = async (blob, maxBytes = 4096) => {
      const buf = await blob.arrayBuffer();
      const view = new Uint8Array(buf.slice(0, Math.min(buf.byteLength, maxBytes)));
      let out = '';
      for (let i = 0; i < view.length; i += 16) {
        const slice = view.slice(i, i + 16);
        const hex = [...slice].map(b => b.toString(16).padStart(2, '0')).join(' ');
        const ascii = [...slice].map(b => (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.').join('');
        out += i.toString(16).padStart(8, '0') + '  ' + hex.padEnd(16*3 - 1, ' ') + '  |' + ascii + '|\n';
      }
      if (buf.byteLength > maxBytes) {
        out += '\nâ€¦ ' + (buf.byteLength - maxBytes) + ' bytes truncated';
      }
      return out;
    };

    const toBase64 = (blob) => new Promise(resolve => {
      const fr = new FileReader();
      fr.onload = () => resolve(String(fr.result).split(',')[1] || '');
      fr.readAsDataURL(blob);
    });

    const prettyMaybe = (str, kind) => {
      try {
        if (kind === 'json') {
          return JSON.stringify(JSON.parse(str), null, 2);
        }
        if (kind === 'csv') {
          // Simple CSV to table
          const rows = str.trim().split(/\r?\n/).map(r => r.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/));
          const table = el('table', { style: { width: '100%', borderCollapse: 'collapse' }});
          rows.forEach((row, i) => {
            const tr = el('tr', { });
            row.forEach(cell => {
              const td = el(i===0 ? 'th' : 'td', { style: {
                border: '1px solid #2b335c', padding: '6px 8px', background: i===0 ? '#1a2244' : '#0b1024', color: '#d7e0ff'
              }}, [cell.replace(/^"|"$/g,'')]);
              tr.appendChild(td);
            });
            table.appendChild(tr);
          });
          return table;
        }
        if (kind === 'xml') {
          const xmlDoc = new DOMParser().parseFromString(str, 'application/xml');
          const parseError = xmlDoc.querySelector('parsererror');
          if (parseError) return str;
          const serializer = new XMLSerializer();
          const pretty = serializer.serializeToString(xmlDoc);
          return pretty;
        }
        if (kind === 'rtf') {
          // RTF raw view only (safe): donâ€™t attempt full render to preserve fidelity
          return str;
        }
        return str;
      } catch {
        return str;
      }
    };

    const clearItems = () => {
      itemsContainer.innerHTML = '';
      itemsContainer.appendChild(el('div', { class: 'empty' }, ['ã¾ã ä½•ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ä½•ã‹ã‚’ãƒšãƒ¼ã‚¹ãƒˆã™ã‚‹ã¨ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚']));
      itemCount = 0;
    };

    clearBtn.addEventListener('click', clearItems);

    // Build UI card
    const renderItem = async ({ type, name, blob, textValue }) => {
      itemCount++;
      // Determine kind
      const kind = detectKind(type, name);
      const size = blob ? blob.size : (textValue ? new TextEncoder().encode(textValue).length : 0);
      const url = blob ? URL.createObjectURL(blob) : null;

      const headLeft = el('div', {}, [
        el('div', { class: 'row' }, [
          el('span', { class: 'type-pill' }, [kind.toUpperCase(), ' â€” ', type || '(unknown)']),
          name ? el('span', { class: 'pill' }, ['name: ', name]) : null
        ]),
        el('div', { class: 'meta' }, [
          el('span', {}, ['ã‚µã‚¤ã‚º: ', prettyBytes(size)]),
          el('span', {}, ['ã‚¢ã‚¤ãƒ†ãƒ #: ', String(itemCount)]),
          el('span', {}, [url ? 'URL: blob://' + url.split('/').pop() : 'URL: (text)'])
        ])
      ]);

      const downloadBtn = el('button', { class: 'btn' }, ['ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰']);
      downloadBtn.addEventListener('click', () => {
        const a = document.createElement('a');
        a.href = url || URL.createObjectURL(blobFromString(textValue || '', type || 'text/plain'));
        a.download = (name && name.trim()) || (kind + '-' + String(itemCount) + (type ? '.' + (type.split('/')[1] || 'dat') : '.dat'));
        document.body.appendChild(a);
        a.click();
        a.remove();
      });

      const copyMimeBtn = el('button', { class: 'btn btn-ghost' }, ['MIMEã‚’ã‚³ãƒ”ãƒ¼']);
      copyMimeBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(type || '');
          copyMimeBtn.textContent = 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ';
          setTimeout(() => copyMimeBtn.textContent = 'MIMEã‚’ã‚³ãƒ”ãƒ¼', 1500);
        } catch {}
      });

      const headRight = el('div', { class: 'item-actions' }, [downloadBtn, copyMimeBtn]);

      const head = el('div', { class: 'item-head' }, [headLeft, headRight]);
      const body = el('div', { class: 'item-body' });

      // Raw section
      const rawSection = el('div', {}, [
        el('div', { class: 'section-title' }, ['Rawï¼ˆç”Ÿãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºï¼‰']),
      ]);

      // Preview section
      const previewSection = el('div', {}, [
        el('div', { class: 'section-title' }, ['Previewï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰']),
      ]);

      // Fill sections according to kind
      if (blob) {
        // Binary raw views
        const hex = await toHexDump(blob);
        const base64 = await toBase64(blob);

        const rawTabs = el('div', { class: 'row' }, [
          el('span', { class: 'pill' }, ['Hex']),
          el('span', { class: 'pill' }, ['Base64'])
        ]);
        rawSection.appendChild(rawTabs);

        const hexPre = el('pre', { class: 'mono', style: { maxHeight: '240px' }}, [hex]);
        const b64Pre = el('pre', { class: 'mono', style: { maxHeight: '180px' }}, [base64]);
        rawSection.appendChild(hexPre);
        rawSection.appendChild(b64Pre);

        // Previews
        if (kind === 'image') {
          const img = el('img', { class: 'media', src: url, alt: name || type || 'image' });
          previewSection.appendChild(img);
        } else if (kind === 'video') {
          const vid = el('video', { class: 'media', controls: 'true' });
          vid.src = url;
          previewSection.appendChild(vid);
        } else if (kind === 'audio') {
          const aud = el('audio', { class: 'media', controls: 'true' });
          aud.src = url;
          previewSection.appendChild(aud);
        } else if (kind === 'pdf') {
          const iframe = el('iframe', { class: 'preview-frame', src: url });
          previewSection.appendChild(iframe);
        } else if (kind === 'html') {
          const text = await blob.text().catch(() => '');
          const cleaned = sanitizeSrcDoc(text);
          const iframe = el('iframe', { class: 'preview-frame', sandbox: 'allow-forms allow-pointer-lock allow-same-origin' });
          iframe.srcdoc = cleaned;
          previewSection.appendChild(iframe);

          const plainPre = el('pre', { class: 'mono', style: { maxHeight: '240px' }}, [text]);
          rawSection.appendChild(plainPre);
        } else if (kind === 'text' || kind === 'json' || kind === 'csv' || kind === 'xml' || kind === 'rtf') {
          const text = await blob.text().catch(() => '');
          const pretty = prettyMaybe(text, kind);
          if (pretty instanceof HTMLElement) {
            previewSection.appendChild(pretty);
            rawSection.appendChild(el('pre', { class: 'mono', style: { maxHeight: '240px' }}, [text]));
          } else {
            previewSection.appendChild(el('pre', { class: 'mono wrap', style: { maxHeight: '240px' }}, [pretty]));
            rawSection.appendChild(el('pre', { class: 'mono', style: { maxHeight: '240px' }}, [text]));
          }
        } else {
          previewSection.appendChild(el('div', { class: 'hint' }, ['ã“ã®MIMEã¯ç›´æ¥ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ãã¾ã›ã‚“ã€‚Rawã¨ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚']));
        }
      } else if (typeof textValue === 'string') {
        const kindGuess = detectKind(type || 'text/plain', name);
        const pretty = prettyMaybe(textValue, kindGuess);
        previewSection.appendChild(
          pretty instanceof HTMLElement
            ? pretty
            : el('pre', { class: 'mono wrap', style: { maxHeight: '240px' }}, [pretty])
        );
        rawSection.appendChild(el('pre', { class: 'mono', style: { maxHeight: '240px' }}, [textValue]));
      }

      // Info section
      const info = el('div', { class: 'kv' }, [
        el('b', {}, ['MIME']),
        el('span', {}, [type || '(unknown)']),
        el('b', {}, ['åå‰']),
        el('span', {}, [name || '(none)']),
        el('b', {}, ['ã‚µã‚¤ã‚º']),
        el('span', {}, [prettyBytes(size)]),
      ]);

      body.appendChild(info);
      body.appendChild(previewSection);
      body.appendChild(rawSection);

      const card = el('div', { class: 'item' }, [head, body]);
      itemsContainer.querySelector('.empty')?.remove();
      itemsContainer.appendChild(card);
    };

    // Handle paste via clipboardData
    const handlePasteEvent = async (e) => {
      e.preventDefault(); // prevent native insert to keep zone clean
      const dt = e.clipboardData;
      if (!dt) return;

      // Collect as much as possible
      const types = dt.types || [];
      const added = [];

      // 1) Try items API for files and string types
      if (dt.items && dt.items.length) {
        for (const it of dt.items) {
          try {
            const type = it.type || '';
            if (it.kind === 'file') {
              const file = it.getAsFile();
              if (file) {
                await renderItem({ type: file.type || type || '', name: file.name || '', blob: file });
                added.push(true);
              }
            } else if (it.kind === 'string') {
              // getAsString preserves provided MIME when available
              await new Promise(res => it.getAsString(async (str) => {
                const t = type || 'text/plain';
                await renderItem({ type: t, name: '', textValue: str });
                res();
              }));
              added.push(true);
            }
          } catch {}
        }
      }

      // 2) Fallback: use getData for known types to catch Safari quirks
      const known = ['text/plain','text/html','text/rtf','text/uri-list','application/json','text/csv','application/xml','text/xml'];
      for (const t of known) {
        try {
          const data = dt.getData(t);
          if (data) {
            await renderItem({ type: t, name: '', textValue: data });
          }
        } catch {}
      }

      // 3) Files via DataTransfer.files (e.g., screenshots)
      if (dt.files && dt.files.length) {
        for (const file of dt.files) {
          await renderItem({ type: file.type || '', name: file.name || '', blob: file });
        }
      }

      // Visual feedback
      dropzone.classList.add('highlight');
      setTimeout(() => dropzone.classList.remove('highlight'), 200);
    };

    // Handle drag & drop files
    const handleDrop = async (e) => {
      e.preventDefault();
      dropzone.classList.remove('highlight');
      const dt = e.dataTransfer;
      if (!dt) return;
      if (dt.files && dt.files.length) {
        for (const file of dt.files) {
          await renderItem({ type: file.type || '', name: file.name || '', blob: file });
        }
      }
    };
    const handleDragOver = (e) => { e.preventDefault(); dropzone.classList.add('highlight'); };
    const handleDragLeave = (e) => { dropzone.classList.remove('highlight'); };

    // Clipboard API direct read
    const readClipboard = async () => {
      if (!navigator.clipboard || !navigator.clipboard.read) {
        // Fallback: try readText
        try {
          const text = await navigator.clipboard.readText();
          if (text) {
            await renderItem({ type: 'text/plain', name: '', textValue: text });
            return;
          }
        } catch {}
        alert('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Clipboard.read()ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚ãƒšãƒ¼ã‚¹ãƒˆã‚„ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
        return;
      }
      try {
        const items = await navigator.clipboard.read();
        for (const ci of items) {
          // ci.types: list of MIME strings
          for (const t of ci.types) {
            try {
              const blob = await ci.getType(t);
              // Heuristic filename
              const name = t.replace(/[^\w.-]+/g,'_') + '-' + Date.now();
              await renderItem({ type: t, name, blob });
            } catch {
              // Try as text if blob failed
              if (t.startsWith('text/')) {
                try {
                  const txtBlob = await ci.getType(t);
                  const text = await txtBlob.text();
                  await renderItem({ type: t, name: '', textValue: text });
                } catch {}
              }
            }
          }
        }
      } catch (err) {
        alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã®èª­ã¿å–ã‚ŠãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã§è¨±å¯ã—ã¦ãã ã•ã„ã€‚');
      }
    };

    // Bind events
    dropzone.addEventListener('paste', handlePasteEvent);
    dropzone.addEventListener('dragover', handleDragOver);
    dropzone.addEventListener('dragleave', handleDragLeave);
    dropzone.addEventListener('drop', handleDrop);

    readClipboardBtn.addEventListener('click', readClipboard);

    // Accessibility: focusable zone
    dropzone.setAttribute('tabindex', '0');

    // Global paste as backup (e.g., if user pastes without focusing zone)
    window.addEventListener('paste', (e) => {
      if (document.activeElement !== dropzone) {
        handlePasteEvent(e);
      }
    });

    // Cleanup blob URLs when leaving
    window.addEventListener('beforeunload', () => {
      document.querySelectorAll('img,video,audio,iframe').forEach(elm => {
        const src = elm.src || elm.getAttribute('srcdoc');
        if (src && src.startsWith('blob:')) URL.revokeObjectURL(src);
      });
    });
  </script>
</body>
</html>
