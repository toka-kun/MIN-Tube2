<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Robot Vision 3D — Corporate Bright HUD</title>
<style>
  :root {
    /* Corporate bright, Unity風のクリーン＆モダン */
    --bg: #0b0e12;
    --surface: #12161c;
    --surface2: #151b22;
    --text: #e9f0f7;
    --muted: #a9b6c5;
    --accent: #00c7ff;   /* シアン */
    --accent2: #6df3ff;  /* 明るいシアン */
    --accent3: #6ae3ff;  /* 補助 */
    --accent-contrast: #004c66;
    --border: #1f2a35;
    --danger: #ff4d68;
    --ok: #41f19e;
    --shadow: rgba(0, 0, 0, 0.45);
  }

  * { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); }
  body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Sans", "Noto Sans JP", "Yu Gothic", sans-serif; overflow: hidden; }

  /* Stage */
  #stage { position: fixed; inset: 0; background: radial-gradient(1200px 900px at 70% 25%, #0c1117 0%, #0b1016 65%, #0a0f15 100%); }
  #glcanvas { width: 100%; height: 100%; display: block; }

  /* Top bar */
  header {
    position: fixed; top: 0; left: 0; right: 0;
    height: 72px; display: flex; align-items: center; gap: 14px;
    padding: 0 18px;
    background: linear-gradient(180deg, rgba(13,18,24,0.85), rgba(13,18,24,0.55) 70%, transparent);
    border-bottom: 1px solid var(--border);
    backdrop-filter: blur(8px);
    z-index: 10;
  }
  header h1 {
    margin: 0; font-size: 18px; letter-spacing: 0.3px;
    color: var(--accent2);
    text-shadow: 0 0 12px rgba(0,199,255,0.35);
  }
  .badge {
    border: 1px solid var(--border);
    border-radius: 999px; padding: 4px 10px; font-size: 12px; color: var(--muted);
  }
  .spacer { flex: 1; }

  /* Controls panel */
  .panel {
    position: fixed; top: 84px; left: 16px;
    width: 360px; max-height: calc(100vh - 120px);
    background: linear-gradient(180deg, rgba(20,27,34,0.95), rgba(20,27,34,0.85));
    border: 1px solid var(--border);
    border-radius: 16px;
    box-shadow: 0 15px 40px var(--shadow);
    overflow: hidden;
    z-index: 9;
  }
  .section { padding: 14px 14px; border-bottom: 1px solid rgba(255,255,255,0.04); }
  .section:last-child { border-bottom: none; }
  .section h2 {
    margin: 0 0 10px; font-size: 13px; text-transform: uppercase; letter-spacing: 1.2px; color: var(--muted);
  }
  .matrix-accent {
    height: 2px; border-radius: 999px;
    background: linear-gradient(90deg, rgba(0,199,255,0), rgba(0,199,255,0.35), rgba(0,199,255,0));
    margin: 2px 0 10px;
    box-shadow: 0 0 20px rgba(0,199,255,0.2) inset;
  }

  /* Form controls */
  .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin-bottom: 6px; }
  .label { font-size: 13px; color: var(--text); }
  .value {
    font-size: 12px; color: var(--muted);
    border: 1px solid var(--border); border-radius: 8px; padding: 2px 6px;
    background: var(--surface2);
  }
  input[type="range"] {
    width: 100%;
    appearance: none; height: 6px; border-radius: 999px;
    background: linear-gradient(90deg, var(--accent-contrast), var(--accent));
    outline: none; opacity: 0.85;
  }
  input[type="range"]::-webkit-slider-thumb {
    appearance: none; width: 16px; height: 16px; border-radius: 50%;
    background: linear-gradient(180deg, var(--accent2), var(--accent));
    border: 1px solid #0b2d38; box-shadow: 0 4px 10px rgba(0,199,255,0.35);
  }
  input[type="file"] {
    width: 100%;
    padding: 10px; border: 1px solid var(--border); border-radius: 12px;
    background: var(--surface2); color: var(--text);
  }
  .buttons { display: flex; gap: 8px; flex-wrap: wrap; }
  button {
    padding: 10px 12px;
    background: linear-gradient(180deg, #14212a, #101b24);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 12px;
    cursor: pointer; transition: transform .08s ease, border-color .2s ease, box-shadow .2s ease;
  }
  button:hover { transform: translateY(-1px); border-color: rgba(0,199,255,0.45); box-shadow: 0 8px 20px rgba(0,199,255,0.20); }
  button.primary { color: var(--accent2); border-color: rgba(0,199,255,0.55); }
  button.danger { color: var(--danger); border-color: rgba(255,77,104,0.45); }

  /* Status bar */
  #status {
    position: fixed; bottom: 12px; left: 12px; right: 12px;
    display: flex; gap: 16px; align-items: center; justify-content: flex-end;
    padding: 10px 12px;
    border: 1px solid var(--border); border-radius: 14px;
    background: rgba(18,22,28,0.6); backdrop-filter: blur(6px);
    font-size: 12px; color: var(--muted); z-index: 8;
  }
  .stat { color: var(--accent2); }

  /* Center focus */
  #reticle {
    position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
    width: 160px; height: 160px; pointer-events: none;
    border: 1px dashed rgba(0,199,255,0.30);
    border-radius: 10px;
    box-shadow: 0 0 60px rgba(0,199,255,0.12), inset 0 0 40px rgba(0,199,255,0.10);
    z-index: 7;
  }

  /* Hidden media/canvas */
  .hidden { display: none !important; }
</style>
</head>
<body>
<div id="stage"><canvas id="glcanvas"></canvas></div>

<header>
  <h1>Robot Vision 3D</h1>
  <span class="badge">WebGL2 • 高速点群</span>
  <span class="badge">写真・動画 → 3D空間図形</span>
  <div class="spacer"></div>
  <span class="badge">Bright Corporate HUD</span>
</header>

<aside class="panel">
  <div class="section">
    <h2>入力</h2>
    <div class="matrix-accent"></div>
    <input id="fileInput" type="file" accept="image/*,video/*" />
    <div class="buttons" style="margin-top:8px;">
      <button id="clearBtn" class="danger">クリア</button>
      <div id="videoControls" class="hidden">
        <button id="playBtn" class="primary">再生</button>
        <button id="pauseBtn">一時停止</button>
      </div>
    </div>
    <p class="label" style="margin-top:10px; color: var(--muted);">大きい動画は自動的にサンプリング密度を最適化して高いFPSを維持します。</p>
  </div>

  <div class="section">
    <h2>視点（スライダー）</h2>
    <div class="matrix-accent"></div>

    <div class="row"><span class="label">FOV（遠近感）</span><span class="value"><span id="fovVal">85</span>°</span></div>
    <input id="fov" type="range" min="45" max="110" step="1" value="85" />

    <div class="row"><span class="label">Yaw（水平回転）</span><span class="value"><span id="yawVal">0.00</span></span></div>
    <input id="yaw" type="range" min="-314" max="314" step="1" value="0" />

    <div class="row"><span class="label">Pitch（上下回転）</span><span class="value"><span id="pitchVal">0.18</span></span></div>
    <input id="pitch" type="range" min="-120" max="120" step="1" value="18" />

    <div class="row"><span class="label">距離（ズーム）</span><span class="value"><span id="distVal">800</span></span></div>
    <input id="dist" type="range" min="100" max="6000" step="10" value="800" />

    <div class="row"><span class="label">パン X</span><span class="value"><span id="panXVal">0</span></span></div>
    <input id="panX" type="range" min="-2000" max="2000" step="10" value="0" />

    <div class="row"><span class="label">パン Y</span><span class="value"><span id="panYVal">0</span></span></div>
    <input id="panY" type="range" min="-2000" max="2000" step="10" value="0" />
  </div>

  <div class="section">
    <h2>表示情報</h2>
    <div class="matrix-accent"></div>
    <div class="row"><span class="label">点数</span><span class="value"><span id="count">0</span></span></div>
    <div class="row"><span class="label">入力サイズ</span><span class="value"><span id="size">0×0</span></span></div>
    <div class="row"><span class="label">FPS</span><span class="value"><span id="fps">0</span></span></div>
  </div>
</aside>

<div id="reticle"></div>

<div id="status">
  <span>視点: <span class="stat" id="view">yaw/pitch/dist/pan</span></span>
</div>

<!-- Hidden media/canvas for texture updates -->
<video id="video" class="hidden" muted playsinline></video>
<canvas id="offscreen" class="hidden"></canvas>

<script>
(() => {
  const glcanvas = document.getElementById('glcanvas');
  const fileInput = document.getElementById('fileInput');
  const offscreen = document.getElementById('offscreen');
  const video = document.getElementById('video');

  const fpsEl = document.getElementById('fps');
  const countEl = document.getElementById('count');
  const sizeEl = document.getElementById('size');
  const viewEl = document.getElementById('view');

  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const videoControls = document.getElementById('videoControls');
  const clearBtn = document.getElementById('clearBtn');

  // Sliders
  const fovSlider = document.getElementById('fov');
  const yawSlider = document.getElementById('yaw');
  const pitchSlider = document.getElementById('pitch');
  const distSlider = document.getElementById('dist');
  const panXSlider = document.getElementById('panX');
  const panYSlider = document.getElementById('panY');

  const fovVal = document.getElementById('fovVal');
  const yawVal = document.getElementById('yawVal');
  const pitchVal = document.getElementById('pitchVal');
  const distVal = document.getElementById('distVal');
  const panXVal = document.getElementById('panXVal');
  const panYVal = document.getElementById('panYVal');

  function resizeCanvas() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const w = glcanvas.clientWidth;
    const h = glcanvas.clientHeight;
    glcanvas.width = Math.floor(w * dpr);
    glcanvas.height = Math.floor(h * dpr);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // WebGL2
  const gl = glcanvas.getContext('webgl2', { antialias: false, preserveDrawingBuffer: false, powerPreference: 'high-performance' });
  if (!gl) {
    alert('WebGL2がサポートされていません。最新のブラウザでお試しください。');
    return;
  }

  // Shaders（ロボット視界: 明るさ→奥行き、点はクリーンなシアン系）
  const vs = `#version 300 es
  precision highp float;
  layout(location=0) in vec2 aPos;      // world X/Y
  layout(location=1) in vec2 aUV;       // texture UV
  uniform mat4 uProj;
  uniform mat4 uView;
  uniform float uDepthScale;            // depth range in pixels
  uniform float uGain;                  // brightness gain
  uniform float uThreshold;             // brightness threshold mask
  uniform float uPointBase;             // base point size influence
  uniform sampler2D uTex;
  out float vLum;
  void main() {
    vec3 rgb = texture(uTex, aUV).rgb;
    float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
    lum = clamp(lum * uGain, 0.0, 1.0);
    float mask = step(uThreshold, lum);

    // depth: brightest -> nearest, darkest -> far
    float z = (1.0 - lum) * uDepthScale;
    vec3 pos = vec3(aPos.x, -aPos.y, -z);
    vec4 clip = uProj * uView * vec4(pos, 1.0);
    gl_Position = clip;

    // perspective point size scaling with distance
    float dist = length((uView * vec4(pos,1.0)).xyz);
    float size = uPointBase * (900.0 / (dist + 120.0));
    gl_PointSize = clamp(size, 0.6, 9.0) * mask;

    vLum = lum * mask;
  }`;
  const fs = `#version 300 es
  precision highp float;
  in float vLum;
  out vec4 outColor;
  void main() {
    vec2 p = gl_PointCoord * 2.0 - 1.0;
    float r = dot(p,p);
    if (r > 1.0) discard;

    // Corporate bright cyan HUD
    float alpha = smoothstep(1.0, 0.0, r) * (0.35 + 0.65 * vLum);
    vec3 base = vec3(0.07, 0.13, 0.18);          // 深めのベース
    vec3 hud = mix(base, vec3(0.0, 0.78, 1.0), vLum); // シアンへ
    outColor = vec4(hud, alpha);
  }`;

  function compile(type, src) {
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(sh));
      throw new Error('Shader compile error');
    }
    return sh;
  }
  function link(vsSrc, fsSrc) {
    const prog = gl.createProgram();
    gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsSrc));
    gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsSrc));
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(prog));
      throw new Error('Program link error');
    }
    return prog;
  }
  const prog = link(vs, fs);
  gl.useProgram(prog);

  const loc = {
    aPos: 0, aUV: 1,
    uProj: gl.getUniformLocation(prog, 'uProj'),
    uView: gl.getUniformLocation(prog, 'uView'),
    uDepthScale: gl.getUniformLocation(prog, 'uDepthScale'),
    uGain: gl.getUniformLocation(prog, 'uGain'),
    uThreshold: gl.getUniformLocation(prog, 'uThreshold'),
    uPointBase: gl.getUniformLocation(prog, 'uPointBase'),
    uTex: gl.getUniformLocation(prog, 'uTex')
  };

  // Static render state
  gl.clearColor(0.04, 0.07, 0.10, 1.0);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.disable(gl.DEPTH_TEST);
  gl.enable(gl.PROGRAM_POINT_SIZE);

  // Texture setup
  const tex = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.uniform1i(loc.uTex, 0);

  // Geometry buffers
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const posBuf = gl.createBuffer();
  const uvBuf = gl.createBuffer();

  // Camera
  let camYaw = 0.0, camPitch = 0.18, camDist = 800;
  let camX = 0, camY = 0;
  let isDrag = false, isPan = false;
  let lastX = 0, lastY = 0;

  function perspective(fovDeg, aspect, near, far) {
    const f = 1.0 / Math.tan((fovDeg * Math.PI / 180) / 2);
    return new Float32Array([
      f/aspect, 0, 0, 0,
      0, f, 0, 0,
      0, 0, (far+near)/(near-far), -1,
      0, 0, (2*far*near)/(near-far), 0
    ]);
  }
  function multiply(a,b) {
    const out = new Float32Array(16);
    for (let i=0;i<4;i++){
      for(let j=0;j<4;j++){
        out[i*4+j] =
          a[i*4+0]*b[0*4+j] +
          a[i*4+1]*b[1*4+j] +
          a[i*4+2]*b[2*4+j] +
          a[i*4+3]*b[3*4+j];
      }
    }
    return out;
  }
  function rotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    return new Float32Array([ c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1 ]);
  }
  function rotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    return new Float32Array([ 1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1 ]);
  }
  function translation(x,y,z) {
    return new Float32Array([ 1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1 ]);
  }

  function updateViewLabel() {
    viewEl.textContent = `yaw:${camYaw.toFixed(2)} pitch:${camPitch.toFixed(2)} dist:${Math.round(camDist)} pan:${Math.round(camX)},${Math.round(camY)}`;
  }
  updateViewLabel();

  // Mouse controls
  glcanvas.addEventListener('mousedown', (e) => {
    if (e.button === 0) isDrag = true;
    if (e.button === 2) isPan = true;
    lastX = e.clientX; lastY = e.clientY;
  });
  glcanvas.addEventListener('contextmenu', (e) => e.preventDefault());
  window.addEventListener('mouseup', () => { isDrag = false; isPan = false; });
  window.addEventListener('mousemove', (e) => {
    if (!isDrag && !isPan) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;
    if (isDrag) {
      camYaw += dx * 0.005;
      camPitch = Math.max(-1.2, Math.min(1.2, camPitch + dy * 0.005));
      yawSlider.value = Math.round(camYaw * 100); // sync slider
      pitchSlider.value = Math.round(camPitch * 100);
      yawVal.textContent = (Number(yawSlider.value)/100).toFixed(2);
      pitchVal.textContent = (Number(pitchSlider.value)/100).toFixed(2);
    }
    if (isPan) {
      camX += dx * 0.8;
      camY -= dy * 0.8;
      panXSlider.value = Math.round(camX);
      panYSlider.value = Math.round(camY);
      panXVal.textContent = panXSlider.value;
      panYVal.textContent = panYSlider.value;
    }
    updateViewLabel();
  });
  glcanvas.addEventListener('wheel', (e) => {
    camDist = Math.max(100, Math.min(6000, camDist + e.deltaY * 0.6));
    distSlider.value = Math.round(camDist);
    distVal.textContent = distSlider.value;
    updateViewLabel();
  }, { passive: true });
  glcanvas.addEventListener('dblclick', () => {
    camYaw = 0.0; camPitch = 0.18; camDist = 800; camX = 0; camY = 0;
    yawSlider.value = 0; pitchSlider.value = 18; distSlider.value = 800; panXSlider.value = 0; panYSlider.value = 0;
    yawVal.textContent = '0.00'; pitchVal.textContent = '0.18'; distVal.textContent = '800'; panXVal.textContent = '0'; panYVal.textContent = '0';
    updateViewLabel();
  });

  // Slider events
  function syncSliderLabels() {
    fovVal.textContent = fovSlider.value;
    yawVal.textContent = (Number(yawSlider.value) / 100).toFixed(2);
    pitchVal.textContent = (Number(pitchSlider.value) / 100).toFixed(2);
    distVal.textContent = distSlider.value;
    panXVal.textContent = panXSlider.value;
    panYVal.textContent = panYSlider.value;
  }
  syncSliderLabels();

  fovSlider.addEventListener('input', syncSliderLabels);
  yawSlider.addEventListener('input', () => {
    camYaw = Number(yawSlider.value) / 100;
    syncSliderLabels(); updateViewLabel();
  });
  pitchSlider.addEventListener('input', () => {
    camPitch = Number(pitchSlider.value) / 100;
    syncSliderLabels(); updateViewLabel();
  });
  distSlider.addEventListener('input', () => {
    camDist = Number(distSlider.value);
    syncSliderLabels(); updateViewLabel();
  });
  panXSlider.addEventListener('input', () => {
    camX = Number(panXSlider.value);
    syncSliderLabels(); updateViewLabel();
  });
  panYSlider.addEventListener('input', () => {
    camY = Number(panYSlider.value);
    syncSliderLabels(); updateViewLabel();
  });

  // Adaptive grid & media
  let gridW = 0, gridH = 0, pointCount = 0;
  let mediaW = 0, mediaH = 0;
  let isVideo = false;
  let playing = false;
  const ctx = offscreen.getContext('2d', { alpha: false });

  // Fixed visual params（ロボット視界に合うMAX奥行き＋控えめしきい値）
  const POINT_BASE = 3.2;      // ベース点サイズ
  const GAIN = 1.25;           // 明るさゲイン
  const THRESH = 0.05;         // 暗部も拾いつつノイズ抑制
  const MAX_POINTS_TARGET = 180000; // 高パフォーマンスを狙う標準点数

  function buildGrid(imgW, imgH, step) {
    gridW = Math.max(1, Math.floor(imgW / step));
    gridH = Math.max(1, Math.floor(imgH / step));
    pointCount = gridW * gridH;

    const pos = new Float32Array(pointCount * 2);
    const uv = new Float32Array(pointCount * 2);

    const worldW = imgW;
    const worldH = imgH;
    const halfW = worldW / 2;
    const halfH = worldH / 2;

    let idx = 0;
    for (let y = 0; y < gridH; y++) {
      const py = y * step + step * 0.5;
      const ny = (py - halfH) / halfH;
      for (let x = 0; x < gridW; x++) {
        const px = x * step + step * 0.5;
        const nx = (px - halfW) / halfW;
        pos[idx*2+0] = nx * halfW;
        pos[idx*2+1] = ny * halfH;
        uv[idx*2+0] = px / imgW;
        uv[idx*2+1] = py / imgH;
        idx++;
      }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);

    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
    gl.bufferData(gl.ARRAY_BUFFER, uv, gl.STATIC_DRAW);
    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(1);

    countEl.textContent = pointCount.toLocaleString();
  }

  function computeStep(imgW, imgH) {
    const pixels = imgW * imgH;
    const step = Math.max(2, Math.floor(Math.sqrt(pixels / MAX_POINTS_TARGET)));
    return step;
  }

  function handleImage(img) {
    mediaW = img.naturalWidth;
    mediaH = img.naturalHeight;
    sizeEl.textContent = `${mediaW}×${mediaH}`;

    const step = computeStep(mediaW, mediaH);
    buildGrid(mediaW, mediaH, step);

    offscreen.width = mediaW;
    offscreen.height = mediaH;
    ctx.drawImage(img, 0, 0, mediaW, mediaH);

    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, offscreen);
  }

  function handleVideo(url) {
    isVideo = true;
    video.src = url;
    videoControls.classList.remove('hidden');
    video.addEventListener('loadeddata', () => {
      mediaW = video.videoWidth;
      mediaH = video.videoHeight;
      sizeEl.textContent = `${mediaW}×${mediaH}`;
      const step = computeStep(mediaW, mediaH);
      buildGrid(mediaW, mediaH, step);
    }, { once: true });
  }

  async function handleFile(file) {
    if (!file) return;
    resetMedia();
    const url = URL.createObjectURL(file);
    if (file.type.startsWith('video/')) {
      handleVideo(url);
      try { await video.play(); playing = true; } catch(e) { playing = false; }
    } else {
      const img = new Image();
      img.onload = () => handleImage(img);
      img.src = url;
      videoControls.classList.add('hidden');
    }
  }

  function resetMedia() {
    if (isVideo) {
      video.pause();
      playing = false;
      video.src = '';
    }
    isVideo = false;
    videoControls.classList.add('hidden');
    mediaW = 0; mediaH = 0;
    pointCount = 0;
    countEl.textContent = '0';
    sizeEl.textContent = '0×0';
  }

  // Events
  fileInput.addEventListener('change', (e) => handleFile(e.target.files?.[0]));
  clearBtn.addEventListener('click', () => { resetMedia(); gl.clear(gl.COLOR_BUFFER_BIT); });
  playBtn.addEventListener('click', async () => { try { await video.play(); playing = true; } catch(e) { /* ignore */ } });
  pauseBtn.addEventListener('click', () => { video.pause(); playing = false; });

  // Render loop
  let lastTS = performance.now(), frames = 0, lastFPSUpdate = performance.now();

  function render(ts) {
    // FPS
    const dt = ts - lastTS; lastTS = ts; frames++;
    if (ts - lastFPSUpdate > 500) {
      fpsEl.textContent = Math.round(frames * 1000 / (ts - lastFPSUpdate));
      frames = 0; lastFPSUpdate = ts;
    }

    // Update texture for video
    if (isVideo && playing && video.readyState >= 2) {
      offscreen.width = video.videoWidth;
      offscreen.height = video.videoHeight;
      ctx.drawImage(video, 0, 0, offscreen.width, offscreen.height);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, offscreen);
    }

    // Clear
    gl.viewport(0, 0, glcanvas.width, glcanvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (pointCount > 0) {
      // Camera from sliders
      const aspect = glcanvas.width / glcanvas.height;
      const fovDeg = Number(fovSlider.value);
      const proj = perspective(fovDeg, aspect, 1, 30000);
      const rot = multiply(rotationY(camYaw), rotationX(camPitch));
      const view = multiply(rot, translation(-camX, -camY, -camDist));

      gl.uniformMatrix4fv(loc.uProj, false, proj);
      gl.uniformMatrix4fv(loc.uView, false, view);

      // Depth scale: 入力サイズから強い奥行き感を生成
      const depthScale = Math.max(mediaW, mediaH) * 1.3;
      gl.uniform1f(loc.uDepthScale, depthScale);
      gl.uniform1f(loc.uGain, GAIN);
      gl.uniform1f(loc.uThreshold, THRESH);
      gl.uniform1f(loc.uPointBase, POINT_BASE);

      gl.bindVertexArray(vao);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.drawArrays(gl.POINTS, 0, pointCount);
    }

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // Initialize slider defaults to camera
  (function initFromSliders(){
    camYaw = Number(yawSlider.value) / 100;
    camPitch = Number(pitchSlider.value) / 100;
    camDist = Number(distSlider.value);
    camX = Number(panXSlider.value);
    camY = Number(panYSlider.value);
    updateViewLabel();
  })();

})();
</script>
</body>
</html>
