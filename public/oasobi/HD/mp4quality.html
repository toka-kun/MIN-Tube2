<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hiâ€‘Res Audio Uploader â€” Analyze, Upsample, Bass & Ultraâ€‘Deep</title>
<meta name="description" content="Upload MP3/Audio, analyze waveform/spectrum/phase, upsample to Hiâ€‘Res, bass boost & ultraâ€‘deep sub, download WAV. Singleâ€‘file, fast, beautifully styled." />
<style>
  :root {
    --bg: #0b0f14;
    --panel: rgba(255, 255, 255, 0.06);
    --panel-strong: rgba(255, 255, 255, 0.1);
    --text: #e8eef7;
    --muted: #9fb0c7;
    --accent: #6bd1ff;
    --accent-2: #9bffb1;
    --danger: #ff6b8a;
    --ok: #64ffa2;
    --warn: #ffd166;
    --shadow: 0 10px 30px rgba(0,0,0,0.45);
    --radius: 14px;
    --radius-sm: 10px;
    --blur: 14px;
    --grad: linear-gradient(135deg, rgba(107, 209, 255, 0.25), rgba(155, 255, 177, 0.25));
  }
  @media (prefers-color-scheme: light) {
    :root {
      --bg: #f6f8fb;
      --panel: rgba(0, 0, 0, 0.06);
      --panel-strong: rgba(0,0,0,0.08);
      --text: #0c1724;
      --muted: #4d627d;
      --accent: #007aff;
      --accent-2: #10b981;
      --danger: #e11d48;
      --ok: #059669;
      --warn: #d97706;
      --shadow: 0 8px 24px rgba(0,0,0,0.12);
      --grad: linear-gradient(135deg, rgba(0, 122, 255, 0.12), rgba(16, 185, 129, 0.12));
    }
  }
  * { box-sizing: border-box; }
  html, body {
    height: 100%;
    background:
      radial-gradient(circle at 20% -10%, rgba(107, 209, 255, 0.15), transparent 40%),
      radial-gradient(circle at 120% 20%, rgba(155, 255, 177, 0.18), transparent 40%),
      var(--bg);
    color: var(--text);
    font: 16px/1.55 Inter, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    margin: 0;
  }
  .wrap { max-width: 1180px; margin: 32px auto 80px; padding: 0 20px; }
  header { display: flex; align-items: center; justify-content: space-between; gap: 16px; margin-bottom: 22px; }
  .brand { display: flex; align-items: center; gap: 12px; }
  .logo {
    width: 46px; height: 46px; border-radius: 12px;
    background: var(--grad); box-shadow: var(--shadow);
    position: relative; overflow: hidden;
  }
  .logo::after {
    content: "â™«";
    position: absolute; inset: 0; display: grid; place-items: center;
    color: rgba(255,255,255,0.85); font-size: 22px; transform: rotate(-10deg);
    text-shadow: 0 4px 12px rgba(0,0,0,0.25);
  }
  h1 { margin: 0; font-size: 1.35rem; letter-spacing: 0.2px; }
  .sub { color: var(--muted); font-size: 0.92rem; }

  .panel {
    background: linear-gradient(180deg, var(--panel), transparent 120%);
    backdrop-filter: saturate(130%) blur(var(--blur));
    -webkit-backdrop-filter: saturate(130%) blur(var(--blur));
    border: 1px solid var(--panel-strong);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
  }

  .upload {
    padding: 26px; margin-bottom: 18px;
    display: grid; gap: 16px; grid-template-columns: 1fr;
  }
  .drop {
    border: 1.5px dashed rgba(255,255,255,0.22);
    border-radius: var(--radius);
    padding: 24px;
    display: grid; place-items: center; text-align: center;
    background: linear-gradient(135deg, rgba(255,255,255,0.05), transparent 60%);
    transition: border-color .2s, transform .2s, background .2s;
    position: relative; overflow: hidden;
  }
  .drop.dragover { border-color: var(--accent); background: linear-gradient(135deg, rgba(255,255,255,0.09), transparent 60%); transform: scale(1.01); }
  .drop p { margin: 8px 0 0; color: var(--muted); }
  .controls {
    display: grid; gap: 12px;
    grid-template-columns: repeat(4,1fr);
  }
  .controls > div, .extra > div {
    background: linear-gradient(180deg, rgba(255,255,255,0.04), transparent 120%);
    border: 1px solid var(--panel-strong);
    border-radius: var(--radius-sm);
    padding: 14px; display: grid; gap: 8px;
  }
  .extra { display: grid; gap: 12px; grid-template-columns: repeat(4,1fr); }
  label { font-size: 0.86rem; color: var(--muted); }
  select, input[type="checkbox"], input[type="range"] { accent-color: var(--accent); }
  select, button {
    width: 100%;
    background: rgba(255,255,255,0.06);
    color: var(--text);
    border: 1px solid var(--panel-strong);
    border-radius: 10px; padding: 10px 12px; font: inherit;
  }
  .range {
    display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center;
  }
  .range output { color: var(--muted); font-size: 0.9rem; min-width: 56px; text-align: right; }
  button.primary {
    background: linear-gradient(135deg, rgba(107,209,255,0.22), rgba(155,255,177,0.2));
    border: 1px solid rgba(107,209,255,0.4);
  }
  button:disabled { opacity: .6; cursor: not-allowed; }
  .row { display: grid; grid-template-columns: 1.1fr 1fr; gap: 18px; margin-top: 18px; }
  .stats { padding: 18px; display: grid; gap: 10px; }
  .grid2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
  .kpi {
    background: linear-gradient(180deg, rgba(255,255,255,0.04), transparent 120%);
    border: 1px solid var(--panel-strong);
    border-radius: var(--radius-sm);
    padding: 12px; min-height: 68px;
  }
  .kpi b { display: block; font-size: 0.83rem; color: var(--muted); }
  .kpi span { font-size: 1rem; }

  .vis { padding: 16px; display: grid; gap: 12px; grid-template-columns: 1fr; }
  .vis .grid3 { display: grid; gap: 12px; grid-template-columns: 1fr 1fr 1fr; }
  canvas {
    width: 100%; height: 160px; background: rgba(0,0,0,0.1);
    border-radius: var(--radius-sm);
    border: 1px solid var(--panel-strong);
  }
  .players { padding: 16px; display: grid; gap: 12px; grid-template-columns: 1fr 1fr; }
  audio { width: 100%; }

  .progress { display: none; padding: 14px; align-items: center; gap: 12px; }
  .progress[data-show="1"] { display: flex; }
  .bar { flex: 1; height: 10px; background: rgba(255,255,255,0.08); border-radius: 20px; overflow: hidden; border: 1px solid var(--panel-strong); }
  .bar > i { display: block; height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); transition: width .15s linear; }
  .small { color: var(--muted); font-size: 0.85rem; }

  .footer { margin-top: 22px; padding: 14px; text-align: center; color: var(--muted); }

  /* playful overlay symbols */
  .symbols {
    pointer-events: none; position: absolute; inset: 0; overflow: hidden;
  }
  .symbols span {
    position: absolute; color: rgba(255,255,255,0.12);
    font-size: clamp(16px, 2.5vw, 24px);
    animation: float 12s linear infinite;
    filter: blur(0.2px);
  }
  @keyframes float {
    0% { transform: translateY(0) rotate(0deg); opacity: .15; }
    50% { opacity: .25; }
    100% { transform: translateY(-120%) rotate(20deg); opacity: .1; }
  }
  @media (max-width: 1100px) {
    .controls { grid-template-columns: 1fr 1fr; }
    .extra { grid-template-columns: 1fr 1fr; }
    .row { grid-template-columns: 1fr; }
    .players { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Hiâ€‘Res Audio Uploader</h1>
          <div class="sub">è§£æãƒ»ãƒã‚¤ãƒ¬ã‚¾å¤‰æ›ãƒ»é‡ä½éŸ³å¼·åŒ–ãƒ»è¶…æ·±éŸ³ãƒ»è¦–è¦šåŒ–ï¼ˆæ³¢å½¢/ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ /ä½ç›¸ï¼‰</div>
        </div>
      </div>
    </header>

    <section class="panel upload" style="position:relative;">
      <div class="symbols" aria-hidden="true" id="symbols"></div>
      <div id="drop" class="drop">
        <div>
          <strong>ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</strong> ã¾ãŸã¯
          <label for="file" style="color: var(--accent); text-decoration: underline; cursor: pointer;">ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ</label>
          <p>å¯¾å¿œ: mp3, m4a, wav, flac(ä¸€éƒ¨), ogg, webm ãªã©ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ä¾å­˜ï¼‰</p>
        </div>
        <input id="file" type="file" accept="audio/*" hidden />
      </div>

      <div class="controls">
        <div>
          <label>å‡ºåŠ›ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ</label>
          <select id="sr">
            <option value="96000" selected>96,000 Hz</option>
            <option value="88200">88,200 Hz</option>
            <option value="48000">48,000 Hz</option>
            <option value="44100">44,100 Hz</option>
            <option value="192000">192,000 Hzï¼ˆé«˜è² è·ï¼‰</option>
          </select>
        </div>
        <div>
          <label>é‡å­åŒ–ãƒ“ãƒƒãƒˆæ·±åº¦</label>
          <select id="bitdepth">
            <option value="24" selected>24-bit PCMï¼ˆãƒ‡ã‚£ã‚¶ï¼‰</option>
            <option value="32f">32-bit Floatï¼ˆå¯é€†ï¼‰</option>
            <option value="16">16-bit PCMï¼ˆãƒ‡ã‚£ã‚¶ï¼‰</option>
          </select>
        </div>
        <div>
          <label>é«˜å“ä½ã‚¨ãƒ³ãƒãƒ³ã‚¹</label>
          <div class="small">
            <input id="enhance" type="checkbox" /> ãƒã‚¤ã‚·ã‚§ãƒ«ãƒ• + ã‚½ãƒ•ãƒˆãƒªãƒŸãƒƒãƒˆ
          </div>
        </div>
        <div>
          <label>æ“ä½œ</label>
          <button id="process" class="primary" disabled>è§£æã—ã¦ãƒã‚¤ãƒ¬ã‚¾åŒ–</button>
        </div>
      </div>

      <div class="extra">
        <div>
          <label>é‡ä½éŸ³ï¼ˆãƒ­ãƒ¼ã‚·ã‚§ãƒ«ãƒ•ï¼‰</label>
          <div class="range">
            <input id="bassGain" type="range" min="0" max="12" value="4" step="0.5" />
            <output id="bassGainOut">+4 dB</output>
          </div>
          <div class="range">
            <input id="bassFreq" type="range" min="40" max="200" value="90" step="5" />
            <output id="bassFreqOut">90 Hz</output>
          </div>
        </div>
        <div>
          <label>è¶…æ·±éŸ³ï¼ˆã‚µãƒ–ãƒãƒ¼ãƒ¢ãƒ‹ã‚¯ã‚¹ï¼‰</label>
          <div class="small" style="display:flex;align-items:center;gap:8px;">
            <input id="subEnable" type="checkbox" />
            <span>æœ‰åŠ¹åŒ–ï¼ˆ30â€“60Hz ã‚’ä»˜åŠ ï¼‰</span>
          </div>
          <div class="range">
            <input id="subAmt" type="range" min="0" max="100" value="35" step="1" />
            <output id="subAmtOut">35 %</output>
          </div>
          <div class="range">
            <input id="subTune" type="range" min="30" max="70" value="45" step="1" />
            <output id="subTuneOut">45 Hz</output>
          </div>
        </div>
        <div>
          <label>ã‚¹ãƒ†ãƒ¬ã‚ªæ„Ÿ</label>
          <div class="range">
            <input id="width" type="range" min="80" max="160" value="110" step="1" />
            <output id="widthOut">110 %</output>
          </div>
          <div class="small">
            ãƒŸãƒƒãƒ‰/ã‚µã‚¤ãƒ‰å‡¦ç†ã§è‡ªç„¶ã«ãƒ¯ã‚¤ãƒ‰åŒ–ï¼ˆãƒ¢ãƒäº’æ›ï¼‰
          </div>
        </div>
        <div>
          <label>ä¿è­·/ä»•ä¸Šã’</label>
          <div class="small" style="display:flex;flex-direction:column;gap:6px;">
            <label><input id="hpProtect" type="checkbox" checked /> ã‚µãƒ–ã‚½ãƒ‹ãƒƒã‚¯HPFï¼ˆ25Hzï¼‰</label>
            <label><input id="ceiling" type="checkbox" checked /> ã»ã®ã‹ãªãƒ–ãƒªãƒƒã‚¯ã‚¦ã‚©ãƒ¼ãƒ«ï¼ˆ-0.3dBFSï¼‰</label>
          </div>
        </div>
      </div>

      <div id="progress" class="progress" aria-live="polite" aria-atomic="true">
        <div class="bar"><i id="bar"></i></div>
        <div id="progtxt" class="small">æº–å‚™ä¸­â€¦</div>
      </div>
    </section>

    <section class="row">
      <div class="panel stats">
        <div class="grid2">
          <div class="kpi"><b>ãƒ•ã‚¡ã‚¤ãƒ«å</b><span id="k_name">â€“</span></div>
          <div class="kpi"><b>å½¢å¼ / æ¨å®šãƒ“ãƒƒãƒˆãƒ¬ãƒ¼ãƒˆ</b><span id="k_fmt">â€“</span></div>
          <div class="kpi"><b>æ™‚é–“ / ãƒãƒ£ãƒ³ãƒãƒ«</b><span id="k_time">â€“</span></div>
          <div class="kpi"><b>ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ</b><span id="k_sr">â€“</span></div>
        </div>
        <div class="grid2">
          <div class="kpi"><b>ãƒ”ãƒ¼ã‚¯</b><span id="k_peak">â€“</span></div>
          <div class="kpi"><b>RMS (å…¨ä½“)</b><span id="k_rms">â€“</span></div>
          <div class="kpi"><b>ã‚¹ãƒšã‚¯ãƒˆãƒ«é‡å¿ƒ</b><span id="k_sc">â€“</span></div>
          <div class="kpi"><b>ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãƒ¬ãƒ³ã‚¸</b><span id="k_dr">â€“</span></div>
        </div>
      </div>

      <div class="panel vis">
        <div class="grid3">
          <div>
            <label class="small">æ³¢å½¢</label>
            <canvas id="wave" height="160" aria-label="Waveform"></canvas>
          </div>
          <div>
            <label class="small">ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ </label>
            <canvas id="fft" height="160" aria-label="Spectrum"></canvas>
          </div>
          <div>
            <label class="small">ä½ç›¸ã‚¹ã‚³ãƒ¼ãƒ—</label>
            <canvas id="phase" height="160" aria-label="Phase scope"></canvas>
          </div>
        </div>
        <div>
          <label class="small">ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ãƒ»ãƒªãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ</label>
          <canvas id="tech" height="120" aria-label="Technical readout"></canvas>
        </div>
      </div>
    </section>

    <section class="panel players">
      <div>
        <label>å…ƒã®éŸ³å£°</label>
        <audio id="orig" controls preload="metadata"></audio>
      </div>
      <div>
        <label>ãƒã‚¤ãƒ¬ã‚¾ï¼ˆå‡ºåŠ›ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰</label>
        <audio id="out" controls preload="metadata"></audio>
      </div>
      <div style="grid-column: 1 / -1; display:flex; gap:12px; flex-wrap: wrap; align-items: center;">
        <button id="download" disabled>WAV ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        <span id="outinfo" class="small">â€“</span>
      </div>
    </section>

    <div class="footer small">
      ãƒ­ãƒ¼ã‚«ãƒ«ã§å®Œçµã€‚éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã¯ã‚µãƒ¼ãƒãƒ¼ã¸é€ä¿¡ã•ã‚Œã¾ã›ã‚“ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®æ©Ÿèƒ½/ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯å¯¾å¿œã«ä¾å­˜ã—ã¾ã™ã€‚
    </div>
  </div>

<script>
(() => {
  const $ = (sel) => document.querySelector(sel);

  const el = {
    drop: $('#drop'),
    file: $('#file'),
    process: $('#process'),
    sr: $('#sr'),
    bitdepth: $('#bitdepth'),
    enhance: $('#enhance'),
    progress: $('#progress'),
    bar: $('#bar'),
    progtxt: $('#progtxt'),
    k: {
      name: $('#k_name'),
      fmt: $('#k_fmt'),
      time: $('#k_time'),
      sr: $('#k_sr'),
      peak: $('#k_peak'),
      rms: $('#k_rms'),
      sc: $('#k_sc'),
      dr: $('#k_dr'),
    },
    wave: $('#wave'),
    fft: $('#fft'),
    phase: $('#phase'),
    tech: $('#tech'),
    orig: $('#orig'),
    out: $('#out'),
    download: $('#download'),
    outinfo: $('#outinfo'),
    // FX controls
    bassGain: $('#bassGain'),
    bassGainOut: $('#bassGainOut'),
    bassFreq: $('#bassFreq'),
    bassFreqOut: $('#bassFreqOut'),
    subEnable: $('#subEnable'),
    subAmt: $('#subAmt'),
    subAmtOut: $('#subAmtOut'),
    subTune: $('#subTune'),
    subTuneOut: $('#subTuneOut'),
    width: $('#width'),
    widthOut: $('#widthOut'),
    hpProtect: $('#hpProtect'),
    ceiling: $('#ceiling'),
    symbols: $('#symbols'),
  };

  let ctx; // decode/visualize AudioContext
  let analyser, analyserTime, splitter, merger, gainVis;
  let fileObj = null;
  let decoded = null;
  let rendered = null;
  let renderedBlob = null;
  let renderedURL = null;

  // Music/Electronic symbols floating
  const SYM = ["â™«","â™¬","â™©","â™ª","â™­","â™¯","ğ„","ğ„¢","Ã˜","âˆ†","Î©","Î»","Âµ","Ï€","âˆ¿","â‰‹"];
  function populateSymbols() {
    el.symbols.innerHTML = '';
    const n = 18;
    for (let i=0;i<n;i++) {
      const s = document.createElement('span');
      s.textContent = SYM[Math.floor(Math.random()*SYM.length)];
      s.style.left = Math.random()*100 + '%';
      s.style.bottom = (-10 + Math.random()*40) + 'px';
      s.style.animationDelay = (Math.random()*10) + 's';
      s.style.animationDuration = (10 + Math.random()*10) + 's';
      el.symbols.appendChild(s);
    }
  }
  populateSymbols();

  // Inline Web Worker for WAV encoding (24/16 PCM + TPDF dither, or 32f)
  const workerCode = `
    let ditherTri = (len, amp) => {
      const out = new Float32Array(len);
      for (let i=0;i<len;i++) {
        const u1 = Math.random(); const u2 = Math.random();
        out[i] = (u1 + u2 - 1) * amp;
      }
      return out;
    };
    function writeWAVHeader(view, sampleRate, channels, bitDepth, dataBytes) {
      const writeStr = (off, str) => { for(let i=0;i<str.length;i++) view.setUint8(off + i, str.charCodeAt(i)); };
      const blockAlign = channels * (bitDepth === "32f" ? 4 : (bitDepth/8));
      const byteRate = sampleRate * blockAlign;
      const bits = bitDepth === "32f" ? 32 : bitDepth;
      const formatCode = bitDepth === "32f" ? 3 : 1;
      writeStr(0, "RIFF");
      view.setUint32(4, 36 + dataBytes, true);
      writeStr(8, "WAVE");
      writeStr(12, "fmt ");
      view.setUint32(16, 16, true);
      view.setUint16(20, formatCode, true);
      view.setUint16(22, channels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bits, true);
      writeStr(36, "data");
      view.setUint32(40, dataBytes, true);
    }
    onmessage = (e) => {
      const { type, buffers, sampleRate, bitDepth } = e.data;
      if (type !== 'encode') return;
      const channels = buffers.length;
      const length = buffers[0].length;
      let interleaved, dataBytes, wav;
      if (bitDepth === '32f') {
        interleaved = new Float32Array(length * channels);
        for (let i=0, w=0; i<length; i++) for (let ch=0; ch<channels; ch++) interleaved[w++] = buffers[ch][i];
        dataBytes = interleaved.byteLength;
        wav = new ArrayBuffer(44 + dataBytes);
        const view = new DataView(wav);
        writeWAVHeader(view, sampleRate, channels, '32f', dataBytes);
        new Float32Array(wav, 44).set(interleaved);
        postMessage({ ok: true, blob: new Blob([wav], {type: 'audio/wav'}) });
        return;
      }
      const bps = bitDepth; // 16 or 24
      const maxInt = bps === 16 ? 32767 : 8388607;
      const bytesPerSample = bps === 16 ? 2 : 3;
      dataBytes = length * channels * bytesPerSample;
      wav = new ArrayBuffer(44 + dataBytes);
      const view = new DataView(wav);
      writeWAVHeader(view, sampleRate, channels, bps, dataBytes);
      const ditherAmp = 1.0 / maxInt;
      const d = ditherTri(length * channels, ditherAmp);
      let offset = 44, di = 0;
      for (let i=0; i<length; i++) {
        for (let ch=0; ch<channels; ch++) {
          let s = buffers[ch][i] + d[di++];
          if (s > 1) s = 1; else if (s < -1) s = -1;
          const v = Math.round(s * maxInt);
          if (bps === 16) {
            view.setInt16(offset, v, true); offset += 2;
          } else {
            const val = v < 0 ? v + 16777216 : v;
            view.setUint8(offset, val & 0xFF); offset++;
            view.setUint8(offset, (val >> 8) & 0xFF); offset++;
            view.setUint8(offset, (val >> 16) & 0xFF); offset++;
          }
        }
      }
      postMessage({ ok: true, blob: new Blob([wav], {type: 'audio/wav'}) });
    };
  `;
  const worker = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })));

  function setProgress(show, ratio, text) {
    el.progress.setAttribute('data-show', show ? '1' : '0');
    if (typeof ratio === 'number') el.bar.style.width = Math.max(0, Math.min(100, ratio * 100)).toFixed(1) + '%';
    if (text) el.progtxt.textContent = text;
  }
  function fmtTime(sec) { const m = Math.floor(sec / 60); const s = Math.round(sec % 60); return `${m}:${s.toString().padStart(2,'0')}`; }
  function guessBitrate(file) { if (!decoded || !file) return 'â€“'; const kbps = (file.size * 8 / decoded.duration) / 1000; return `${Math.round(kbps)} kbps`; }

  async function ensureCtx() {
    if (!ctx) {
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = ctx.createAnalyser();
      analyser.fftSize = 2048;
      analyserTime = ctx.createAnalyser();
      analyserTime.fftSize = 2048;
      gainVis = ctx.createGain();
      gainVis.gain.value = 1;
      splitter = ctx.createChannelSplitter(2);
      merger = ctx.createChannelMerger(2);
    }
  }

  async function decode(file) {
    await ensureCtx();
    const arr = await file.arrayBuffer();
    return await ctx.decodeAudioData(arr);
  }

  function analyze(buffer) {
    const chs = buffer.numberOfChannels;
    const len = buffer.length;
    const sr = buffer.sampleRate;
    const dataL = buffer.getChannelData(0);
    const dataR = chs > 1 ? buffer.getChannelData(1) : dataL;
    const step = Math.max(1, Math.floor(sr / 100));
    let sumSq = 0, peak = 0;
    for (let i=0; i<len; i+=step) { const s = 0.5*(dataL[i] + dataR[i]); const a = Math.abs(s); if (a > peak) peak = a; sumSq += s*s; }
    const samples = Math.ceil(len / step);
    const rms = Math.sqrt(sumSq / samples);

    // quick spectral centroid with a small custom DFT slice
    const N = 2048;
    const start = Math.min(Math.max(0, Math.floor(len/2) - N/2), len - N);
    const win = new Float32Array(N);
    for (let i=0;i<N;i++){ const w = 0.5 - 0.5*Math.cos(2*Math.PI*i/(N-1)); win[i] = (dataL[start+i] + dataR[start+i]) * 0.5 * w; }
    const re = new Float32Array(N/2); const im = new Float32Array(N/2);
    for (let k=0;k<N/2;k++){
      let r=0,i2=0;
      for (let n=0;n<N;n++){ const ang = -2*Math.PI*k*n/N; const c=Math.cos(ang), s=Math.sin(ang); r += win[n]*c; i2 += win[n]*s; }
      re[k]=r; im[k]=i2;
    }
    let num=0, den=0; const nyq = sr/2;
    for (let k=1;k<N/2;k++){ const mag = Math.sqrt(re[k]*re[k]+im[k]*im[k]); const f = k/(N/2)*nyq; num += f*mag; den += mag; }
    const centroid = den>0 ? num/den : 0;
    const dr = 20 * Math.log10((peak || 1e-6) / (rms || 1e-6));
    return { channels: chs, length: len, sampleRate: sr, duration: buffer.duration, peak, rms, centroid, dr };
  }

  // Visuals: waveform, spectrum, phase scope, tech HUD (VU/crest/width)
  let visRAF;
  function startVisualsFromElement(mediaEl) {
    if (!ctx) return;
    if (mediaEl._srcNode) mediaEl._srcNode.disconnect();
    const src = ctx.createMediaElementSource(mediaEl);
    mediaEl._srcNode = src;

    const analyserF = analyser;
    const analyserT = analyserTime;
    src.connect(gainVis);
    gainVis.connect(analyserF);
    gainVis.connect(analyserT);
    // to speakers
    analyserF.connect(ctx.destination);

    const fftData = new Uint8Array(analyserF.frequencyBinCount);
    const timeData = new Float32Array(analyserT.fftSize);
    const waveCtx = el.wave.getContext('2d');
    const fftCtx = el.fft.getContext('2d');
    const phaseCtx = el.phase.getContext('2d');
    const techCtx = el.tech.getContext('2d');

    function drawWave() {
      const W = el.wave.width = el.wave.clientWidth;
      const H = el.wave.height = el.wave.clientHeight;
      analyserT.getFloatTimeDomainData(timeData);
      waveCtx.clearRect(0,0,W,H);
      waveCtx.fillStyle = 'rgba(255,255,255,0.06)';
      waveCtx.fillRect(0,0,W,H);
      waveCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#6bd1ff';
      waveCtx.lineWidth = 1.2;
      waveCtx.beginPath();
      const step = timeData.length / W;
      for (let x=0; x<W; x++) {
        const idx = Math.floor(x*step);
        const v = timeData[idx] || 0;
        const y = (1 - (v*0.9 + 1)/2) * H;
        if (x===0) waveCtx.moveTo(x,y); else waveCtx.lineTo(x,y);
      }
      waveCtx.stroke();
    }

    function drawFFT() {
      const W = el.fft.width = el.fft.clientWidth;
      const H = el.fft.height = el.fft.clientHeight;
      analyserF.getByteFrequencyData(fftData);
      fftCtx.clearRect(0,0,W,H);
      fftCtx.fillStyle = 'rgba(255,255,255,0.06)';
      fftCtx.fillRect(0,0,W,H);
      const grad = fftCtx.createLinearGradient(0,0,0,H);
      grad.addColorStop(0, '#9bffb1'); grad.addColorStop(1, '#6bd1ff');
      fftCtx.fillStyle = grad;
      const n = fftData.length;
      for (let i=0;i<n;i++){
        const v = fftData[i]/255;
        const h = v * H;
        const x = i * (W/n);
        fftCtx.fillRect(x, H-h, Math.max(1, W/n), h);
      }
      // Octave markers
      fftCtx.strokeStyle = 'rgba(255,255,255,0.14)'; fftCtx.lineWidth=1;
      const sr = ctx.sampleRate;
      const nyq = sr/2;
      const marks = [31.5,63,125,250,500,1000,2000,4000,8000,16000];
      marks.forEach(f=>{
        const bin = Math.floor((f/nyq)*n);
        const x = bin*(W/n);
        fftCtx.beginPath(); fftCtx.moveTo(x,0); fftCtx.lineTo(x,H); fftCtx.stroke();
      });
    }

    function drawPhase() {
      const W = el.phase.width = el.phase.clientWidth;
      const H = el.phase.height = el.phase.clientHeight;
      phaseCtx.clearRect(0,0,W,H);
      phaseCtx.fillStyle = 'rgba(255,255,255,0.06)';
      phaseCtx.fillRect(0,0,W,H);
      // get stereo snapshot
      const buf = analyserT.fftSize;
      const l = new Float32Array(buf);
      const r = new Float32Array(buf);
      analyserT.getFloatTimeDomainData(l);
      // approximate R by using a 90-degree rotated version via Hilbert-ish trick (simple delay)
      for (let i=0;i<buf;i++){
        const j = (i+2) % buf;
        r[i] = l[j]; // faux-stereo for scope when only mono analysis node is provided
      }
      phaseCtx.save();
      phaseCtx.translate(W/2,H/2);
      phaseCtx.strokeStyle = 'rgba(107,209,255,0.85)';
      phaseCtx.globalAlpha = 0.85;
      phaseCtx.lineWidth = 0.8;
      phaseCtx.beginPath();
      const scale = Math.min(W,H)/2 * 0.9;
      for (let i=0;i<buf;i+=2){
        const x = (l[i]) * scale;
        const y = (r[i]) * scale;
        if (i===0) phaseCtx.moveTo(x,y); else phaseCtx.lineTo(x,y);
      }
      phaseCtx.stroke();
      // crosshair
      phaseCtx.globalAlpha = 0.25; phaseCtx.strokeStyle='rgba(255,255,255,0.3)';
      phaseCtx.beginPath(); phaseCtx.moveTo(-W/2,0); phaseCtx.lineTo(W/2,0); phaseCtx.stroke();
      phaseCtx.beginPath(); phaseCtx.moveTo(0,-H/2); phaseCtx.lineTo(0,H/2); phaseCtx.stroke();
      phaseCtx.restore();
    }

    function drawTech() {
      const W = el.tech.width = el.tech.clientWidth;
      const H = el.tech.height = el.tech.clientHeight;
      techCtx.clearRect(0,0,W,H);
      techCtx.fillStyle = 'rgba(255,255,255,0.06)'; techCtx.fillRect(0,0,W,H);

      // VU bars
      analyserT.getFloatTimeDomainData(timeData);
      let sum=0, peak=0;
      for (let i=0;i<timeData.length;i++){ const a = Math.abs(timeData[i]); sum += timeData[i]*timeData[i]; if (a>peak) peak=a; }
      const rms = Math.sqrt(sum/timeData.length);
      const crest = peak / (rms||1e-6);
      const toDb = (x)=> 20*Math.log10(x||1e-6);
      const rmsDb = Math.max(-60, Math.min(0, toDb(rms)));
      const peakDb = Math.max(-60, Math.min(0, toDb(peak)));
      const crestDb = toDb(crest);

      const pad=16, barW=(W-4*pad)/3, base=H-28, h=H-48;
      function drawBar(i, valDb, color, label){
        const x = pad + i*(barW+pad);
        const ratio = (valDb+60)/60;
        techCtx.fillStyle = color;
        techCtx.fillRect(x, base - h*ratio, barW, h*ratio);
        techCtx.strokeStyle = 'rgba(255,255,255,0.15)';
        techCtx.strokeRect(x, base - h, barW, h);
        techCtx.fillStyle = 'rgba(255,255,255,0.8)';
        techCtx.font = '12px system-ui, Inter';
        techCtx.fillText(label, x, H-10);
      }
      drawBar(0, rmsDb, '#6bd1ff', 'RMS');
      drawBar(1, peakDb, '#9bffb1', 'PEAK');
      drawBar(2, Math.max(-60, Math.min(20, crestDb-6)), '#ffd166', 'CREST');

      // ceiling indicator
      techCtx.fillStyle = 'rgba(255,255,255,0.5)';
      techCtx.font = '12px system-ui, Inter';
      techCtx.fillText('é›»å­éŸ³ç¬¦: â™« â™¬ â™© â™ª  |  æŠ€è¡“: dBFS, RMS, Peak, Crest', W-320, 16);
    }

    cancelAnimationFrame(visRAF);
    function loop(){
      drawWave(); drawFFT(); drawPhase(); drawTech();
      visRAF = requestAnimationFrame(loop);
    }
    loop();
  }

  function populateMeta(file, buffer, ana) {
    el.k.name.textContent = file.name || 'â€“';
    const ext = (file.name.split('.').pop() || '').toLowerCase();
    el.k.fmt.textContent = `${ext || 'audio'} / ${guessBitrate(file)}`;
    el.k.time.textContent = `${fmtTime(buffer.duration)} / ${buffer.numberOfChannels}ch`;
    el.k.sr.textContent = `${buffer.sampleRate.toLocaleString()} Hz`;
    el.k.peak.textContent = `${(20*Math.log10((ana.peak||1e-6))).toFixed(1)} dBFS`;
    el.k.rms.textContent = `${(20*Math.log10((ana.rms||1e-6))).toFixed(1)} dB`;
    el.k.sc.textContent = `${Math.round(ana.centroid)} Hz`;
    el.k.dr.textContent = `${ana.dr.toFixed(1)} dB`;
  }

  function resetOutput() {
    rendered = null;
    if (renderedURL) URL.revokeObjectURL(renderedURL);
    renderedURL = null;
    renderedBlob = null;
    el.out.removeAttribute('src');
    el.download.disabled = true;
    el.outinfo.textContent = 'â€“';
  }

  async function handleFile(file) {
    resetOutput();
    fileObj = file;
    el.process.disabled = true;
    setProgress(true, 0.05, 'ãƒ‡ã‚³ãƒ¼ãƒ‰ä¸­â€¦');

    try {
      decoded = await decode(file);
      setProgress(true, 0.25, 'è§£æä¸­â€¦');
      const ana = analyze(decoded);
      populateMeta(file, decoded, ana);

      // Original player preview
      const blob = new Blob([await file.arrayBuffer()], { type: file.type || 'audio/mpeg' });
      const url = URL.createObjectURL(blob);
      el.orig.src = url;

      // start live visuals from original element
      startVisualsFromElement(el.orig);

      el.process.disabled = false;
      setProgress(false, 0, '');
    } catch (err) {
      console.error(err);
      alert('ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å¯¾å¿œã—ã¦ã„ãªã„å½¢å¼ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
      setProgress(false, 0, '');
    }
  }

  // Build processing chain in OfflineAudioContext with bass/sub/width/limiters
  function buildProcessingChain(off, buffer, opts) {
    const src = off.createBufferSource();
    src.buffer = buffer;

    // Nodes
    const inputGain = off.createGain();
    inputGain.gain.value = 1.0;

    // Subsonic HPF (protect)
    const hpf = off.createBiquadFilter();
    hpf.type = 'highpass';
    hpf.frequency.value = opts.hpProtect ? 25 : 5;
    hpf.Q.value = 0.707;

    // Low-shelf bass
    const shelf = off.createBiquadFilter();
    shelf.type = 'lowshelf';
    shelf.frequency.value = opts.bassFreq;
    shelf.gain.value = opts.bassGain;

    // Stereo width via M/S matrix
    const split = off.createChannelSplitter(2);
    const merge = off.createChannelMerger(2);
    const midGain = off.createGain();
    const sideGain = off.createGain();
    const m2l = off.createGain(), m2r = off.createGain(), s2l = off.createGain(), s2r = off.createGain();
    const width = opts.widthPct/100;
    midGain.gain.value = 1.0;
    sideGain.gain.value = Math.max(0.5, Math.min(2.0, width));
    // matrix: L = (M + S)/âˆš2, R = (M - S)/âˆš2
    const norm = Math.SQRT1_2;
    m2l.gain.value = norm; m2r.gain.value = norm; s2l.gain.value = norm; s2r.gain.value = -norm;

    // Optional gentle high-shelf + soft limiter
    const hs = off.createBiquadFilter();
    hs.type = 'highshelf'; hs.frequency.value = 9000; hs.gain.value = opts.enhance ? 1.5 : 0;

    // Subharmonic generator (rectify + lowpass tuned + mix)
    const subIn = off.createGain(); subIn.gain.value = 1;
    const shaper = off.createWaveShaper();
    shaper.curve = makeHalfRectifierCurve(2048);
    const subLP = off.createBiquadFilter();
    subLP.type = 'lowpass'; subLP.frequency.value = Math.max(30, Math.min(90, opts.subTune));
    subLP.Q.value = 0.7;
    const subGain = off.createGain();
    subGain.gain.value = opts.subEnable ? (opts.subAmt/100)*0.6 : 0.0; // conservative

    // Pre-limiter trim to preserve headroom
    const preLimit = off.createGain();
    preLimit.gain.value = 0.97;

    // Final dynamics (soft ceiling or transparent)
    const comp = off.createDynamicsCompressor();
    if (opts.ceiling) {
      comp.threshold.value = -0.3;
      comp.knee.value = 8;
      comp.ratio.value = 20;
      comp.attack.value = 0.002;
      comp.release.value = 0.15;
    } else {
      comp.threshold.value = 0;
      comp.ratio.value = 1;
      comp.knee.value = 0;
      comp.attack.value = 0.003;
      comp.release.value = 0.25;
    }

    // Wire up
    src.connect(inputGain);
    inputGain.connect(hpf);
    hpf.connect(shelf);

    // Tap for sub generator (mono feed)
    const monoMix = off.createGain(); monoMix.gain.value = 0.5;
    const monoSum = off.createChannelMerger(1);
    const monoSplit = off.createChannelSplitter(2);
    shelf.connect(monoSplit);
    monoSplit.connect(monoMix, 0);
    monoSplit.connect(monoMix, 1);
    monoMix.connect(subIn);
    subIn.connect(shaper);
    shaper.connect(subLP);
    subLP.connect(subGain);

    // To M/S
    shelf.connect(split);
    // M = (L+R)/âˆš2, S = (L-R)/âˆš2
    const L = off.createGain(); const R = off.createGain();
    split.connect(L,0); split.connect(R,1);
    const sum = off.createGain(); sum.gain.value = Math.SQRT1_2;
    const dif = off.createGain(); dif.gain.value = Math.SQRT1_2;
    L.connect(sum); R.connect(sum);
    L.connect(dif); const invR = off.createGain(); invR.gain.value = -1; R.connect(invR); invR.connect(dif);

    sum.connect(midGain);
    dif.connect(sideGain);

    // Mix sub (mono) into mid only (keeps mono compatibility)
    subGain.connect(midGain);

    midGain.connect(m2l); midGain.connect(m2r);
    sideGain.connect(s2l); sideGain.connect(s2r);

    const outL = off.createGain(); const outR = off.createGain();
    m2l.connect(outL); s2l.connect(outL);
    m2r.connect(outR); s2r.connect(outR);

    // chain finish
    const postMerge = off.createChannelMerger(2);
    outL.connect(postMerge, 0, 0);
    outR.connect(postMerge, 0, 1);

    postMerge.connect(hs);
    hs.connect(preLimit);
    preLimit.connect(comp);
    comp.connect(off.destination);

    return { src, off };
  }

  function makeHalfRectifierCurve(n) {
    const c = new Float32Array(n);
    for (let i=0;i<n;i++){
      const x = (i/(n-1))*2 - 1; // -1..1
      c[i] = Math.max(0, x); // half-wave rectifier to derive sub content
    }
    return c;
  }

  async function upsampleProcess(buffer, targetSR, params) {
    const channels = buffer.numberOfChannels;
    const duration = buffer.duration;
    const length = Math.ceil(duration * targetSR);
    const off = new OfflineAudioContext(channels, length, targetSR);

    const chain = buildProcessingChain(off, buffer, params);
    chain.src.start(0);
    const rendered = await off.startRendering();
    return rendered;
  }

  async function encodeWAV(buffer, sampleRate, bitDepth) {
    const ch = buffer.numberOfChannels;
    const chans = [];
    for (let i=0; i<ch; i++) chans.push(buffer.getChannelData(i));
    return new Promise((resolve, reject) => {
      worker.onmessage = (e) => {
        const { ok, blob, error } = e.data;
        if (ok) resolve(blob);
        else reject(error || 'encoding failed');
      };
      worker.postMessage({ type: 'encode', buffers: chans, sampleRate, bitDepth });
    });
  }

  async function processHiRes() {
    if (!decoded) return;
    const targetSR = parseInt(el.sr.value, 10);
    const bitDepth = el.bitdepth.value; // '24' | '16' | '32f'
    const params = {
      enhance: el.enhance.checked,
      bassGain: parseFloat(el.bassGain.value),
      bassFreq: parseFloat(el.bassFreq.value),
      subEnable: el.subEnable.checked,
      subAmt: parseFloat(el.subAmt.value),
      subTune: parseFloat(el.subTune.value),
      widthPct: parseFloat(el.width.value),
      hpProtect: el.hpProtect.checked,
      ceiling: el.ceiling.checked,
    };

    setProgress(true, 0.05, `ãƒªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°/å‡¦ç†ä¸­ (â†’ ${targetSR.toLocaleString()} Hz)â€¦`);
    try {
      const t0 = performance.now();
      rendered = await upsampleProcess(decoded, targetSR, params);
      setProgress(true, 0.65, 'WAV ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­â€¦');

      const blob = await encodeWAV(rendered, targetSR, bitDepth);
      renderedBlob = blob;
      if (renderedURL) URL.revokeObjectURL(renderedURL);
      renderedURL = URL.createObjectURL(blob);
      el.out.src = renderedURL;
      el.download.disabled = false;

      const sizeMB = (blob.size / (1024*1024)).toFixed(2);
      el.outinfo.textContent = `å‡ºåŠ›: ${targetSR.toLocaleString()} Hz / ${bitDepth.replace('32f','32-bit Float')} / ${rendered.numberOfChannels}ch / ç´„ ${sizeMB} MB`;

      // start visuals on output too (switch when playing)
      el.out.onplay = () => startVisualsFromElement(el.out);
      el.orig.onplay = () => startVisualsFromElement(el.orig);

      const t1 = performance.now();
      setProgress(false, 1, `å®Œäº† (${((t1-t0)/1000).toFixed(2)}s)`);
    } catch (e) {
      console.error(e);
      alert('å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
      setProgress(false, 0, '');
    }
  }

  function downloadOut() {
    if (!renderedBlob) return;
    const ext = 'wav';
    const base = (fileObj?.name || 'audio').replace(/\.[^/.]+$/, '');
    const bitDepth = el.bitdepth.value.replace('32f','32f');
    const fname = `${base}_hires_${el.sr.value}Hz_${bitDepth}.wav`;
    const a = document.createElement('a');
    a.href = renderedURL;
    a.download = fname;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // UI bindings
  el.file.addEventListener('change', (e) => { const f = e.target.files?.[0]; if (f) handleFile(f); });
  ['dragenter','dragover'].forEach(ev => {
    el.drop.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); el.drop.classList.add('dragover'); });
  });
  ['dragleave','drop'].forEach(ev => {
    el.drop.addEventListener(ev, (e) => {
      e.preventDefault(); e.stopPropagation();
      if (ev === 'drop') { const f = e.dataTransfer?.files?.[0]; if (f) handleFile(f); }
      el.drop.classList.remove('dragover');
    });
  });
  el.drop.addEventListener('click', () => el.file.click());
  el.process.addEventListener('click', processHiRes);
  el.download.addEventListener('click', downloadOut);

  // Range outputs
  function bindRange(r, out, fmt) {
    const update = ()=> out.textContent = fmt(parseFloat(r.value));
    r.addEventListener('input', update); update();
  }
  bindRange(el.bassGain, el.bassGainOut, v => `+${v.toFixed(1)} dB`);
  bindRange(el.bassFreq, el.bassFreqOut, v => `${v|0} Hz`);
  bindRange(el.subAmt, el.subAmtOut, v => `${v|0} %`);
  bindRange(el.subTune, el.subTuneOut, v => `${v|0} Hz`);
  bindRange(el.width, el.widthOut, v => `${v|0} %`);

  // Resize redraw to keep canvases crisp
  let resizeTimer;
  window.addEventListener('resize', () => {
    cancelAnimationFrame(resizeTimer);
    resizeTimer = requestAnimationFrame(()=> {
      // canvases redraw will happen on next visual loop tick
    });
  });

})();
</script>
</body>
</html>
